<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        /* Landscape Mobile Optimized CSS */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0f1419;
            color: #e6edf3;
            touch-action: manipulation;
        }

        body {
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        /* Header optimized for landscape */
        .header {
            flex-shrink: 0;
            padding: 12px 16px;
            background: linear-gradient(90deg, #1a2332 0%, #161d2b 100%);
            border-bottom: 1px solid #2d3746;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(90deg, #58a6ff, #2ea043);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            white-space: nowrap;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Status badge for landscape */
        .status-badge {
            background: rgba(46, 160, 67, 0.15);
            color: #2ea043;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid rgba(46, 160, 67, 0.3);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-badge::before {
            content: "";
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #2ea043;
        }

        /* Main content area for landscape */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 16px;
        }

        /* Table container for wide screen */
        .table-container {
            flex: 1;
            background: #161b22;
            border-radius: 12px;
            border: 1px solid #30363d;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        /* Grid layout optimized for landscape (5 columns) */
        .table-header {
            display: grid;
            grid-template-columns: 1.5fr 0.8fr 1fr 1fr 1fr;
            background: #1a1f2e;
            padding: 14px 16px;
            font-weight: 700;
            font-size: 13px;
            color: #8b949e;
            border-bottom: 2px solid #2d3746;
            flex-shrink: 0;
        }

        .table-row {
            display: grid;
            grid-template-columns: 1.5fr 0.8fr 1fr 1fr 1fr;
            padding: 14px 16px;
            align-items: center;
            border-bottom: 1px solid #2d3746;
            transition: background-color 0.2s;
            font-size: 14px;
        }

        .table-row:last-child {
            border-bottom: none;
        }

        .table-row:hover {
            background-color: rgba(88, 166, 255, 0.05);
        }

        /* Column styling */
        .col-sector {
            display: flex;
            align-items: center;
            gap: 12px;
            overflow: hidden;
        }

        .col-ticker {
            text-align: left;
            font-weight: 600;
            color: #c9d1d9;
        }

        .col-price {
            text-align: right;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-weight: 600;
            color: #e6edf3;
        }

        .col-change {
            text-align: right;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 6px;
            justify-self: end;
            min-width: 80px;
            text-align: center;
        }

        .col-updated {
            text-align: right;
            font-size: 12px;
            color: #8b949e;
            white-space: nowrap;
        }

        /* Color indicators */
        .sector-color {
            width: 14px;
            height: 14px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .positive {
            background: rgba(46, 160, 67, 0.15);
            color: #2ea043;
        }

        .negative {
            background: rgba(248, 81, 73, 0.15);
            color: #f85149;
        }

        /* Loading and empty states */
        #sectors-table {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            min-height: 0;
        }

        .loading, .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
            color: #8b949e;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #30363d;
            border-top-color: #58a6ff;
            border-radius: 50%;
            margin-bottom: 16px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Footer for landscape */
        .footer {
            flex-shrink: 0;
            padding: 12px 16px;
            text-align: center;
            font-size: 11px;
            color: #8b949e;
            border-top: 1px solid #2d3746;
            background: #161b22;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .refresh-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .refresh-btn {
            background: #1a1f2e;
            border: 1px solid #30363d;
            color: #e6edf3;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .refresh-btn:hover {
            background: #2d3746;
        }

        .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Update indicator */
        .update-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
        }

        .update-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #2ea043;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Sort controls */
        .sort-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 4px;
        }

        .sort-btn {
            background: #1a1f2e;
            border: 1px solid #30363d;
            color: #8b949e;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .sort-btn:hover {
            background: #2d3746;
        }

        .sort-btn.active {
            background: #1f6feb;
            border-color: #1f6feb;
            color: #ffffff;
        }

        /* For very wide screens (tablet landscape) */
        @media (min-width: 1024px) {
            .table-header, .table-row {
                grid-template-columns: 1.8fr 0.8fr 1fr 1fr 1.2fr;
            }
        }

        /* For narrow landscape (some phones) */
        @media (max-width: 740px) and (orientation: landscape) {
            .table-header, .table-row {
                grid-template-columns: 1.3fr 0.7fr 0.9fr 0.9fr 1fr;
                padding: 12px;
                font-size: 13px;
            }
            
            .col-updated {
                font-size: 11px;
            }
        }

        /* Hide scrollbar but keep functionality */
        #sectors-table::-webkit-scrollbar {
            width: 4px;
        }

        #sectors-table::-webkit-scrollbar-track {
            background: transparent;
        }

        #sectors-table::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <!-- Header optimized for landscape -->
    <div class="header">
        <h1>US Sectors Performance</h1>
        <div class="header-controls">
            <div class="status-badge">LIVE UPDATING</div>
        </div>
    </div>

    <!-- Main content area -->
    <div class="main-content">
        <!-- Sort controls -->
        <div class="sort-controls">
            <button class="sort-btn active" data-sort="change">üìà Change %</button>
            <button class="sort-btn" data-sort="sector">üî§ Sector</button>
            <button class="sort-btn" data-sort="price">üí∞ Price</button>
            <button class="sort-btn" data-sort="ticker">üè∑Ô∏è Ticker</button>
        </div>

        <!-- Table container -->
        <div class="table-container">
            <div class="table-header">
                <div class="col-sector">Sector</div>
                <div class="col-ticker">ETF</div>
                <div class="col-price">Price</div>
                <div class="col-change">Change</div>
                <div class="col-updated">Updated</div>
            </div>
            
            <div id="sectors-table">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <p>Loading sector data...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer with controls -->
    <div class="footer">
        <div class="refresh-info">
            <div class="update-indicator">
                <div class="update-dot"></div>
                <span>Auto-updating every 60s</span>
            </div>
        </div>
        <div>
            <button class="refresh-btn" id="manual-refresh">
                <span>üîÑ</span>
                <span>Refresh Now</span>
            </button>
        </div>
    </div>

    <script>
        // Configuration
        const POLYGON_API_KEY = 'LUAlQX3Ht3YxBpuGgHqTvEvakpCTPFYx'; // Replace with your Polygon.io API key
        const REFRESH_INTERVAL = 60000; // 60 seconds between batch updates
        const BATCH_SIZE = 5; // Polygon free tier allows 5 calls per minute

        // Sector definitions with colors
        const SECTORS = [
            { name: "Technology", ticker: "XLK", color: "#58a6ff" },
            { name: "Healthcare", ticker: "XLV", color: "#2ea043" },
            { name: "Financials", ticker: "XLF", color: "#ffd33d" },
            { name: "Consumer Discretionary", ticker: "XLY", color: "#f778ba" },
            { name: "Industrials", ticker: "XLI", color: "#79c0ff" },
            { name: "Consumer Staples", ticker: "XLP", color: "#a371f7" },
            { name: "Energy", ticker: "XLE", color: "#ff7b72" },
            { name: "Utilities", ticker: "XLU", color: "#8b949e" },
            { name: "Real Estate", ticker: "XLRE", color: "#ffa657" },
            { name: "Materials", ticker: "XLB", color: "#7ee787" },
            { name: "Communication", ticker: "XLC", color: "#d2a8ff" }
        ];

        // Base prices for realistic mock data (approximate as of Dec 2024)
        const BASE_PRICES = {
            'XLK': 228.50, 'XLV': 142.30, 'XLF': 42.85, 'XLY': 185.20,
            'XLI': 126.40, 'XLP': 78.90, 'XLE': 93.75, 'XLU': 66.30,
            'XLRE': 39.85, 'XLB': 89.20, 'XLC': 116.47
        };

        // Application state
        let currentSort = 'change';
        let isRefreshing = false;
        let currentBatch = 0;
        let lastUpdateTime = Date.now();
        let updateInterval;

        // DOM elements
        const sectorsTable = document.getElementById('sectors-table');
        const manualRefreshBtn = document.getElementById('manual-refresh');
        const sortButtons = document.querySelectorAll('.sort-btn');

        // Initialize the application
        function init() {
            console.log('Initializing sector performance tracker...');
            
            // Load initial data from cache
            const cachedData = loadFromCache();
            if (cachedData.length > 0) {
                renderTable(cachedData);
            } else {
                // If no cache, start with mock data
                const mockData = generateMockData();
                renderTable(mockData);
            }
            
            // Start the staggered update cycle
            startUpdateCycle();
            
            // Set up event listeners
            setupEventListeners();
            
            // Initial data fetch
            setTimeout(() => fetchNextBatch(), 1000);
        }

        // Set up all event listeners
        function setupEventListeners() {
            // Manual refresh button
            manualRefreshBtn.addEventListener('click', () => {
                if (!isRefreshing) {
                    fetchNextBatch(true);
                }
            });
            
            // Sort buttons
            sortButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const sortType = btn.dataset.sort;
                    sortButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentSort = sortType;
                    
                    const currentData = loadFromCache();
                    if (currentData.length > 0) {
                        renderTable(sortData(currentData, sortType));
                    }
                });
            });
            
            // Handle page visibility changes
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // Page became visible, check if we need to refresh
                    const timeSinceLastUpdate = Date.now() - lastUpdateTime;
                    if (timeSinceLastUpdate > REFRESH_INTERVAL * 2) {
                        fetchNextBatch();
                    }
                }
            });
        }

        // Start the staggered update cycle
        function startUpdateCycle() {
            clearInterval(updateInterval);
            updateInterval = setInterval(() => {
                if (document.visibilityState === 'visible') {
                    fetchNextBatch();
                }
            }, REFRESH_INTERVAL);
        }

        // Fetch the next batch of sectors (5 at a time)
        async function fetchNextBatch(force = false) {
            if (isRefreshing && !force) return;
            
            isRefreshing = true;
            manualRefreshBtn.disabled = true;
            manualRefreshBtn.innerHTML = '<span>‚è≥</span><span>Updating...</span>';
            
            try {
                const batchSectors = getNextBatch();
                console.log(`Fetching batch ${currentBatch}: ${batchSectors.map(s => s.ticker).join(', ')}`);
                
                const results = [];
                
                for (const sector of batchSectors) {
                    const sectorData = await fetchSectorData(sector);
                    results.push(sectorData);
                    
                    // Delay between requests to be polite to the API
                    await new Promise(resolve => setTimeout(resolve, 1200));
                }
                
                // Update cache with new data
                updateCache(results);
                
                // Load all data from cache and render
                const allData = loadFromCache();
                renderTable(sortData(allData, currentSort));
                
                // Update batch counter
                currentBatch = (currentBatch + 1) % Math.ceil(SECTORS.length / BATCH_SIZE);
                lastUpdateTime = Date.now();
                
                console.log(`Batch ${currentBatch} completed successfully`);
                
            } catch (error) {
                console.error('Error fetching batch:', error);
                
                // Even on error, update the UI with cached data
                const allData = loadFromCache();
                renderTable(sortData(allData, currentSort));
            } finally {
                isRefreshing = false;
                manualRefreshBtn.disabled = false;
                manualRefreshBtn.innerHTML = '<span>üîÑ</span><span>Refresh Now</span>';
            }
        }

        // Get the next batch of sectors to fetch
        function getNextBatch() {
            const start = currentBatch * BATCH_SIZE;
            const end = Math.min(start + BATCH_SIZE, SECTORS.length);
            return SECTORS.slice(start, end);
        }

        // Fetch data for a single sector
        async function fetchSectorData(sector) {
            // If no API key is set, use mock data
            if (!POLYGON_API_KEY || POLYGON_API_KEY === 'YOUR_API_KEY_HERE') {
                console.log(`No API key, using mock data for ${sector.ticker}`);
                return generateSectorMockData(sector);
            }
            
            const url = `https://api.polygon.io/v2/aggs/ticker/${sector.ticker}/prev?adjusted=true&apiKey=${POLYGON_API_KEY}`;
            
            try {
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.status === "OK" && data.results && data.results.length > 0) {
                        const result = data.results[0];
                        const price = result.c;
                        const changePercent = ((result.c - result.o) / result.o) * 100;
                        
                        return {
                            ...sector,
                            price: price,
                            change: parseFloat(changePercent.toFixed(2)),
                            updatedAt: Date.now(),
                            source: 'polygon'
                        };
                    }
                }
                
                console.warn(`Polygon API failed for ${sector.ticker}, using mock data`);
                return generateSectorMockData(sector);
                
            } catch (error) {
                console.error(`Error fetching ${sector.ticker}:`, error);
                return generateSectorMockData(sector);
            }
        }

        // Generate mock data for a sector
        function generateSectorMockData(sector) {
            const basePrice = BASE_PRICES[sector.ticker] || 100;
            const changePercent = (Math.random() * 1 - 0.5); // Small random change
            const price = basePrice * (1 + changePercent / 100);
            
            return {
                ...sector,
                price: parseFloat(price.toFixed(2)),
                change: parseFloat(changePercent.toFixed(2)),
                updatedAt: Date.now(),
                source: 'mock'
            };
        }

        // Generate initial mock data for all sectors
        function generateMockData() {
            return SECTORS.map(sector => generateSectorMockData(sector));
        }

        // Cache management
        function updateCache(sectorData) {
            const cacheKey = 'sectors_performance_cache';
            let cache = JSON.parse(localStorage.getItem(cacheKey) || '{}');
            
            sectorData.forEach(sector => {
                cache[sector.ticker] = {
                    ...sector,
                    cachedAt: Date.now()
                };
            });
            
            localStorage.setItem(cacheKey, JSON.stringify(cache));
        }

        function loadFromCache() {
            const cacheKey = 'sectors_performance_cache';
            const cache = JSON.parse(localStorage.getItem(cacheKey) || '{}');
            
            return SECTORS.map(sector => {
                const cached = cache[sector.ticker];
                
                if (cached) {
                    return {
                        ...sector,
                        price: cached.price || 0,
                        change: cached.change || 0,
                        updatedAt: cached.updatedAt || cached.cachedAt || Date.now(),
                        source: cached.source || 'cache'
                    };
                }
                
                // If not in cache, generate mock data
                return generateSectorMockData(sector);
            });
        }

        // Sort data based on current sort type
        function sortData(data, sortType) {
            const sorted = [...data];
            
            switch (sortType) {
                case 'sector':
                    sorted.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'price':
                    sorted.sort((a, b) => b.price - a.price);
                    break;
                case 'ticker':
                    sorted.sort((a, b) => a.ticker.localeCompare(b.ticker));
                    break;
                case 'change':
                default:
                    sorted.sort((a, b) => b.change - a.change);
                    break;
            }
            
            return sorted;
        }

        // Render the table with sector data
        function renderTable(sectorData) {
            if (sectorData.length === 0) {
                sectorsTable.innerHTML = `
                    <div class="empty-state">
                        <p>No sector data available</p>
                        <button class="refresh-btn" onclick="fetchNextBatch(true)" style="margin-top: 16px;">
                            Try Loading Data
                        </button>
                    </div>
                `;
                return;
            }
            
            const sortedData = sortData(sectorData, currentSort);
            
            const rows = sortedData.map(sector => {
                const changeClass = sector.change >= 0 ? 'positive' : 'negative';
                const changeSign = sector.change >= 0 ? '+' : '';
                const changeText = `${changeSign}${sector.change.toFixed(2)}%`;
                
                // Format the update time
                const updateTime = new Date(sector.updatedAt);
                const now = new Date();
                const diffMinutes = Math.floor((now - updateTime) / (1000 * 60));
                
                let timeText;
                if (diffMinutes < 1) {
                    timeText = 'Just now';
                } else if (diffMinutes < 60) {
                    timeText = `${diffMinutes}m ago`;
                } else {
                    timeText = updateTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                }
                
                // Determine data source indicator
                const sourceIndicator = sector.source === 'polygon' ? 'üîÑ' : 
                                      sector.source === 'cache' ? 'üíæ' : 'üîÑ';
                
                return `
                    <div class="table-row">
                        <div class="col-sector">
                            <div class="sector-color" style="background: ${sector.color}"></div>
                            <div>
                                <div style="font-weight: 600;">${sector.name}</div>
                                <div style="font-size: 11px; color: #8b949e; margin-top: 2px;">
                                    ${sourceIndicator} ${sector.source}
                                </div>
                            </div>
                        </div>
                        <div class="col-ticker">${sector.ticker}</div>
                        <div class="col-price">$${sector.price.toFixed(2)}</div>
                        <div class="col-change ${changeClass}">${changeText}</div>
                        <div class="col-updated">${timeText}</div>
                    </div>
                `;
            }).join('');
            
            sectorsTable.innerHTML = rows;
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
            // Small delay to allow CSS to adjust
            setTimeout(() => {
                const currentData = loadFromCache();
                if (currentData.length > 0) {
                    renderTable(sortData(currentData, currentSort));
                }
            }, 100);
        });
    </script>
</body>
</html>